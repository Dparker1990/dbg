# `dlv debug`: From build to CLI

*TODO*: What is this document about?

Delve commands (those that follow `dlv`) are implemented in [commands.go](cmd/dlv/cmds/commands.go) through the [`cobra`](https://github.com/spf13/cobra) package. `dlv debug` is defined as  `debugCommand`, with the corresponding "work function" (in `cobra` terminology, the function that gets called for this command) `debugCmd`, defined also in the same file. This function builds and executes the package specified (execution, in this context implies more than just running the binary).


## Building the package

The build function `gobuild` used by `dlv debug` is mainly a wrapper for the `go build` command with the options necessary for a debug build (disabling optimizations and inlining).


## Running the server

The `execute` function used by `debugCmd` (and similar commands) starts a server that listens for incoming TCP connections. This server will be in charge of running the binary and waiting for commands (e.g., CLI commands generated by the interactive terminal).

The `server` interface implemented in [`ServerImpl`](/service/rpccommon/server.go) is started with the `Run` function which creates a [`Debugger`](/service/debugger/debugger.go) and listens for TCP connections with RPC requests for the debugger. The `ServerImpl` structure has a `net.Listener` that accepts TCP connections and passes the received data to the [`RPCServer`](/service/rpccommon/server.go) (of which there are actually two, one for each API version) through the [`serveJSONCodec`](/service/rpccommon/server.go) function.

*TODO*: Describe the `for` with the main server goroutine.


## Launching an interactive terminal

Returning to the almighty [`execute`](/cmd/dlv/cmds/commands.go) function, after running the running the server that will be accepting the RPC calls, an interactive [`terminal`](/pkg/terminal/terminal.go) (supported by the [`liner`](https://github.com/peterh/liner) package) will be created that will act as the RPC client v2 (assuming we are not running in headless mode). Inside the terminal's `Run` function there's a main `for` loop that prompts the user for input and tries to execute the command written by the user.


## Debugger

When the debugger is created in [`New`](/service/debugger/debugger.go), configured with the `Config` structure, launches the target process through the `Launch` function (in the default case, it can also attach to a running process or open a core file). In the default case [`native.Launch`](/pkg/proc/native/proc_linux.go) is used, where a `Process` structure is created and executed through the standard [`exec.Command`](https://golang.org/pkg/os/exec/#Command) and [`(*Cmd).Start`](https://golang.org/pkg/os/exec/#Cmd.Start) methods with `Ptrace` enabled in [`SysProcAttr`](https://golang.org/pkg/syscall/#SysProcAttr).

*TODO*: Continue with initializeDebugProcess.
